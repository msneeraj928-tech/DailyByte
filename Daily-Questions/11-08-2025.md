## Day 11-08-2025: Nth Fibonacci Term

### Difficulty: Easy

## Problem Statement

The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones. The sequence typically starts with 0 and 1.

Fibonacci Sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

Given an integer `n`, return the nth term of the Fibonacci sequence. Assume the sequence is 0-indexed, where:
- F(0) = 0
- F(1) = 1
- F(n) = F(n-1) + F(n-2) for n > 1

## Examples

### Example 1
```
Input: n = 0
Output: 0
Explanation:
The 0th Fibonacci number is 0.
```

### Example 2
```
Input: n = 1
Output: 1
Explanation:
The 1st Fibonacci number is 1.
```

### Example 3
```
Input: n = 5
Output: 5
Explanation:
The Fibonacci sequence up to n=5: 0, 1, 1, 2, 3, 5
The 5th Fibonacci number is 5.
```

### Example 4
```
Input: n = 10
Output: 55
Explanation:
The Fibonacci sequence up to n=10: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
The 10th Fibonacci number is 55.
```

### Example 5
```
Input: n = 2
Output: 1
Explanation:
The Fibonacci sequence up to n=2: 0, 1, 1
The 2nd Fibonacci number is 1.
```

## Constraints

- 0 <= n <= 30
- You can assume n is a valid non-negative integer.

## Follow-up

Can you solve this problem in O(n) time and O(1) space? Can you think of a way to solve it in O(log n) time using matrix exponentiation?

## Hints

<details>
<summary>Hint 1</summary>
The simplest approach is to use iteration. Keep track of the last two Fibonacci numbers and compute the next one.
</details>

<details>
<summary>Hint 2</summary>
You can also use recursion, but be careful about redundant calculations. Consider using memoization to optimize.
</details>

<details>
<summary>Hint 3</summary>
For an iterative solution with O(1) space, you only need to maintain two variables for the previous two Fibonacci numbers.
</details>

## Suggested Approach (short contract)

- Input: an integer `n` (0-indexed position in Fibonacci sequence).
- Output: the nth Fibonacci number.
- Error modes: if `n` is negative, handle appropriately (can return -1 or throw error).
- Success: correctly calculate the nth Fibonacci number.

Edge cases:
- n = 0 (should return 0)
- n = 1 (should return 1)
- n = 2 (should return 1)
- Large values of n (up to 30)

## Time & Space Complexity

### Approach 1: Recursive (without memoization)
- Time: O(2^n) â€” exponential due to repeated calculations.
- Space: O(n) â€” recursion stack depth.

### Approach 2: Recursive with Memoization
- Time: O(n) â€” each Fibonacci number computed once.
- Space: O(n) â€” memoization array + recursion stack.

### Approach 3: Iterative
- Time: O(n) â€” linear iteration from 0 to n.
- Space: O(1) â€” only storing the last two numbers.

### Approach 4: Matrix Exponentiation
- Time: O(log n) â€” using fast matrix exponentiation.
- Space: O(1) â€” constant space for matrix operations.

## Example Implementation Ideas

### Approach 1: Iterative (Recommended)
- Initialize two variables for F(0) and F(1).
- Iterate from 2 to n, updating the variables.
- Return the nth Fibonacci number.

### Approach 2: Recursive with Memoization
- Create a memoization array/dictionary.
- Implement a recursive function that checks memo before computing.
- Store results in memo to avoid recomputation.

### Approach 3: Dynamic Programming
- Create an array to store all Fibonacci numbers up to n.
- Fill the array iteratively.
- Return the value at index n.

## Code Templates

### JavaScript
```javascript
function fibonacci(n) {
    // Your code here
}
```

### Python
```python
def fibonacci(n):
    # Your code here
    pass
```

### Java
```java
public class Solution {
    public int fibonacci(int n) {
        // Your code here
    }
}
```

### C++
```cpp
class Solution {
public:
    int fibonacci(int n) {
        // Your code here
    }
};
```

## Submission Guidelines

1. Create your solution file at `Daily-Solutions/11-08-2025/githubusername_ERPID.<ext>` (use `.py`, `.js`, `.java`, `.cpp` etc. based on your language).
2. Include a header comment block with:
   - Problem name
   - Date
   - Your name and GitHub username
   - ERP ID
   - Approach explanation
   - Complexity analysis
3. Test your solution with the provided examples and edge cases.
4. Ensure your code follows proper naming conventions and is well-documented.
5. Submit via Pull Request following the repo README guidelines.

## Deadline

**Submit by:** 24 hours from problem release

---

Good luck and happy coding! ðŸ’»

---
